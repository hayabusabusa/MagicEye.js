/*! MagicEye.js (https://github.com/peeinears/MagicEye.js)
 *
 *  MIT License (http://www.opensource.org/licenses/mit-license.html)
 *  Copyright (c) 2014 Ian Pearce
 */

!(function(){
  'use strict';

  const isNodeJS = typeof window === "undefined";
  const Canvas = isNodeJS ? require('canvas') : undefined;
  const FS = isNodeJS ? require('fs') : undefined;

  var MagicEye = {

    render: function (opts) {
      opts = opts || {};

      var defaultOptions = {
        width: null,
        height: null,
        depthMap: null,
        depthMapper: new MagicEye.DepthMapper(),
        imageType: 'png',
        output: null,
        colors: [
          [255, 255, 255, 255],
          [0, 0, 0, 255]
        ]
      };

      for (var property in defaultOptions) {
        if( ! opts.hasOwnProperty(property) ) opts[property] = defaultOptions[property];
      }

      var element, width, height, depthMap, pixelData, i;

      // find and set element
      if (!isNodeJS && opts.el) {
        element = (typeof opts.el === 'string' ? document.getElementById(opts.el) : opts.el);
        if (!element || !element.tagName) throw('MagicEye: Could not find element: ' + opts.el);
      }

      // use element's height and width unless height and width is provided
      width = opts.width || element.width;
      if (!width) throw('MagicEye: width not set and could not be inferred from element: ' + opts.el);
      height = opts.height || element.height;
      if (!height) throw('MagicEye: height not set and could not be inferred from element: ' + opts.el);

      // use depthMap if provided, otherwise use depthMap generated by given depthMapper
      if (opts.depthMap) {
        depthMap = opts.depthMap;
      } else if (opts.depthMapper) {
        depthMap = opts.depthMapper.generate(width, height);
      } else throw('MagicEye: no depthMap or depthMapper opts given');

      // check output dir
      if (isNodeJS && !opts.output) {
        throw('MagicEye: Must provide output filename when in Node context');
      }

      // convert hex colors to RGBa
      for (i = 0; i < opts.colors.length; i++) {
        if (typeof opts.colors[i] === 'string') {
          opts.colors[i] = this.helpers.hexToRGBa(opts.colors[i]);
        }
      }

      pixelData = this.generatePixelData({
        width: width,
        height: height,
        depthMap: depthMap,
        colors: opts.colors
      });

      if (isNodeJS) {
        this.renderToPngImage(opts.output, pixelData, width, height);
        return;
      }

      switch (element.tagName) {
      case 'CANVAS':
        this.renderToCanvas(element, pixelData, width, height);
        break;

      case 'IMG':
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        this.renderToCanvas(canvas, pixelData, width, height);
        element.src = canvas.toDataURL('image/' + (opts.imageType || 'png'));
        break;

      default:
        throw('MagicEye: el must be either a <canvas> or an <img>');
      }

      return this;
    },

    renderToCanvas: function (canvas, pixelData, width, height) {
      var context = canvas.getContext("2d"),
          imageData = context.createImageData(width, height);
      imageData.data.set(pixelData);
      context.putImageData(imageData, 0, 0);
    },

    renderToPngImage: function (output, pixelData, width, height) {
      const canvas = Canvas.createCanvas(width, height);
      const context = canvas.getContext("2d");
      const imageData = context.createImageData(width, height);

      imageData.data.set(pixelData);
      context.putImageData(imageData, 0, 0);

      const writeStream = FS.createWriteStream(__dirname + "/" + output + ".png");
      const pngStream = canvas.pngStream();

      pngStream.on("data", function(chunk) {
        writeStream.write(chunk);
      });

      pngStream.on("end", function(chunk) {
        console.log("save png to", writeStream.path);
      });
    },

    generatePixelData: function (opts) {

      /*
       * This algorithm was published in a paper authored by by Harold W.
       * Thimbleby, Stuart Inglis, and Ian H. Witten. The following code was
       * translated from the C code that was featured in the article.
       * http://www.cs.sfu.ca/CourseCentral/414/li/material/refs/SIRDS-Computer-94.pdf
       */

      var x, y, i, left, right, visible, t, zt, k, sep, z, pixelOffset, rgba,
          width = opts.width,
          height = opts.height,
          depthMap = opts.depthMap,
          numColors = opts.colors.length,
          same, // points to a pixel to the right
          dpi = 72, // assuming output of 72 dots per inch
          eyeSep = Math.round(2.5 * dpi), // eye separation assumed to be 2.5 inches
          mu = (1 / 3), // depth of field (fraction of viewing distance)
          pixels = new Uint8ClampedArray(width * height * 4);

      // for each row
      for (y = 0; y < height; y++) {
        // max image width (for Uint16Array) is 65536
        same = new Uint16Array(width); // points to a pixel to the right

        for (x = 0; x < width; x++) {
          same[x] = x; // each pixel is initially linked with itself
        }

        // for each column
        for (x = 0; x < width; x++) {

          z = depthMap[y][x];

          // stereo separation corresponding to z
          sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

          // x-values corresponding to left and right eyes
          left = Math.round(x - ((sep + (sep & y & 1)) / 2));
          right = left + sep;

          if (0 <= left && right < width) {

            // remove hidden surfaces
            t = 1;
            do {
              zt = z + (2 * (2 - (mu * z)) * t / (mu * eyeSep));
              visible = (depthMap[y][x-t] < zt) && (depthMap[y][x+t] < zt); // false if obscured
              t++;
            } while (visible && zt < 1);

            if (visible) {
              // record that left and right pixels are the same
              for (k = same[left]; k !== left && k !== right; k = same[left]) {
                if (k < right) {
                  left = k;
                } else {
                  left = right;
                  right = k;
                }
              }
              same[left] = right;
            }
          }
        }

        for (x = (width - 1); x >= 0; x--) {
          pixelOffset = (y * width * 4) + (x * 4);
          if (same[x] === x) {
            // set random color
            rgba = opts.colors[Math.floor(Math.random() * numColors)];
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = rgba[i];
            }
          } else {
            // constrained pixel, obey constraint
            pixelOffset = (y * width * 4) + (x * 4);
            for (i = 0; i < 4; i++) {
              pixels[pixelOffset + i] = pixels[(y * width * 4) + (same[x] * 4) + i];
            }
          }
        }
      }

      return pixels;
    },

    helpers: {

      // http://stackoverflow.com/a/5624139
      hexToRGBa: function (hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16),
          255
        ] : null;
      }
    }

  };


// -- DepthMapper --

  var DepthMapper = function () {};

  DepthMapper.prototype.autoResize = true;

  DepthMapper.prototype.make = function (width, height) {
    // !!! Overwrite this method
    return [[0]];
  };

  DepthMapper.prototype.generate = function (width, height) {
    if (this.autoResize) return this.resize(this.make(width, height), width, height);
    else return this.make(width, height);
  };

  DepthMapper.prototype.resize = function (origDepthMap, width, height) {
    var origDepthMapY, x, y,
        resizedDepthMap = [],
        origDepthMapHeight = origDepthMap.length,
        origDepthMapWidth = origDepthMap[0].length;

    if (origDepthMapWidth === width && origDepthMapHeight === height) {
      return origDepthMap;
    }

    for (y = 0; y < height; y++) {
      resizedDepthMap[y] = new Float32Array(width);
      origDepthMapY = Math.floor(y * origDepthMapHeight / height);
      for (x = 0; x < width; x++) {
        resizedDepthMap[y][x] = origDepthMap[origDepthMapY][Math.floor(x * origDepthMapWidth / width)];
      }
    }

    return resizedDepthMap;
  };

  // Credit: backbone, underscore
  DepthMapper.extend = function (protoProps) {
    var parent = this;
    var child;

    var extend = function(obj) {
      if (!obj || (typeof obj != 'function' && typeof obj != 'object')) return obj;
      var source, prop;
      for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
          obj[prop] = source[prop];
        }
      }
      return obj;
    };

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && hasOwnProperty.call(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  MagicEye.DepthMapper = DepthMapper;

// -- Text Depth Mapper

  MagicEye.TextDepthMapper = MagicEye.DepthMapper.extend({

    constructor: function (text, opts) {
      this.text = text;
      this.opts = opts;
    },
  
    make: function (width, height) {
      var canvas = isNodeJS ? Canvas.createCanvas(width, height) : document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
  
      var context = canvas.getContext("2d");
      context.fillStyle = "rgb(0, 0, 0)";
      context.fillRect(0, 0, width, height);
      context.fillStyle = 'rgb(255,255,255)';
  
      var defaultTextWrapperOptions = {
        font: "bold 48px Helvetica, Arial, sans-serif",
        paddingX: Math.round(width * 0.1),
        paddingY: Math.round(height * 0.1),
        sizeToFill: true,
        verticalAlign: 'middle'
      };
  
      this.opts = this.opts || {};
  
      for (var property in defaultTextWrapperOptions) {
        this.opts[property] = (this.opts && this.opts[property]) ? this.opts[property] : defaultTextWrapperOptions[property];
      }
  
      new CanvasTextWrapper(
        canvas,
        this.text,
        this.opts
      );
  
      var x, y, offset,
          depthMap = [],
          pixelData = context.getImageData(0, 0, width, height).data;
      for (y = 0; y < height; y++) {
        depthMap[y] = new Float32Array(width);
        offset = width * y * 4;
        for (x = 0; x < width; x++) {
          // assume grayscale (R, G, and B are equal)
          depthMap[y][x] = pixelData[offset + (x * 4)] / 255;
        }
      }
      return depthMap;
    }
  
  });

  /*! CanvasTextWrapper (https://github.com/namniak/CanvasTextWrapper, forked to peeinears/CanvasTextWrapper)
   *  Version:  0.1.0
   *
   *  MIT License (http://www.opensource.org/licenses/mit-license.html)
   *  Copyright (c) 2014 Vadim Namniak
   */
  
  var defaultOptions = {
    font: '18px Arial, sans-serif',
    textAlign: 'left',     // each line of text is aligned left
    verticalAlign: 'top',  // text lines block is aligned top
    paddingX: 0,           // zero px left & right text padding relative to canvas or parent
    paddingY: 0,           // zero px top & bottom text padding relative to canvas or parent
    fitParent: false,      // text is tested to fit canvas width
    lineBreak: 'auto',     // text fills the element's (canvas or parent) width going to a new line on a whole word
    sizeToFill: false      // text is resized to fill the container height (given font size is ignored)
  };

  const canvasTextWrapper = function(canvas, text, opts) {

    if (!(this instanceof CanvasTextWrapper)) {
        throw new TypeError('CanvasTextWrapper constructor failed. Use "new" keyword when instantiating.');
    }

    this.canvas = canvas;
    this.text = text;

    // set options to specified or default values
    for (var property in defaultOptions) {
        this[property] = (opts && opts[property]) ? opts[property] : defaultOptions[property];
    }

    // extract font size
    this.lineHeight = parseInt(this.font.replace(/^\D+/g, ''), 10);

    // validate all set properties
    this.validate();

    // basic context settings
    this.context = this.canvas.getContext('2d');
    this.context.font = this.font;
    this.context.textBaseline = 'bottom';

    this.drawText();
  };

  if (isNodeJS) {
    global.CanvasTextWrapper = canvasTextWrapper;
  } else {
    window.CanvasTextWrapper = canvasTextWrapper;
  }

  CanvasTextWrapper.prototype = {

    drawText: function() {
      var elementWidth = (this.fitParent === false) ? this.canvas.width : this.canvas.parentNode.clientWidth;
      var textPos = {
          x: 0,
          y: 0
      };

      if (this.sizeToFill) {
          // starting at 1px increase font size by 1px until text block exceeds the height of its padded container or until words break
          var elementHeight = ((this.fitParent === false) ? this.canvas.height : this.canvas.parentNode.clientHeight) - (this.paddingX * 2);
          var numWords = this.text.trim().split(/\s+/).length;
          var fontSize = 0;
          do {
              this.setFontSize(++fontSize);
              var lines = this.getWrappedText(elementWidth);
              var textBlockHeight = lines.length * this.lineHeight;
          } while (textBlockHeight < elementHeight && lines.join(' ').split(/\s+/).length == numWords);

          // use previous font size, not the one that broke the while condition
          this.setFontSize(--fontSize);
      }

      var lines = this.getWrappedText(elementWidth);
      var textBlockHeight = lines.length * this.lineHeight;

      // set vertical align for the whole text block
      this.setTextVerticalAlign(textPos, textBlockHeight);

      for (var i = 0; i < lines.length; i++) {
          this.setTextHorizontalAlign(this.context, textPos, elementWidth, lines[i]);

          textPos.y = parseInt(textPos.y) + parseInt(this.lineHeight);
          this.context.fillText(lines[i], textPos.x, textPos.y);
      }
    },

    setFontSize: function(size) {
        var fontParts = this.context.font.split(/\b\d+px\b/i);
        this.context.font = fontParts[0] + size + 'px' + fontParts[1];
        this.lineHeight = size;
    },

    getWrappedText: function(elementWidth) {
      var maxTextLength = elementWidth - (this.paddingX * 2);

      var words = this.text.trim().split(/\s+/);
      var lines = [];

      this.checkWordsLength(this.context, words, maxTextLength);
      this.breakTextIntoLines(this.context, lines, words, maxTextLength);

      return lines;
    },

    checkWordsLength: function(context, words, maxTextLength) {
      for (var i = 0; i < words.length; i++) {
          var testString = '';
          var tokenLen = context.measureText(words[i]).width;

          // check if a word exceeds the element's width
          if (tokenLen > maxTextLength) {
              for (var k = 0; (context.measureText(testString + words[i][k]).width <= maxTextLength) && (k < words[i].length); k++) {
                  testString += words[i][k];
              }

              // break the word because it's too  long
              var sliced = words[i].slice(0, k);
              var leftover = words[i].slice(k);
              words.splice(i, 1, sliced, leftover);
          }
      }
    },

    breakTextIntoLines: function(context, lines, words, maxTextLength) {
      for (var i = 0, j = 0; i < words.length; j++) {
          lines[j] = '';

          if (this.lineBreak === 'auto') {
              // put as many full words in a line as can fit element
              while ((context.measureText(lines[j] + words[i]).width <= maxTextLength) && (i < words.length)) {
                  lines[j] += words[i] + ' ';
                  i++;
              }
              lines[j] = lines[j].trim();
          } else if (this.lineBreak === 'word') {
              // put each next word in a new line
              lines[j] = words[i];
              i++;
          }
      }
    },

    setTextHorizontalAlign: function(context, textPos, elementWidth, line) {
      if (this.textAlign === 'center') {
          textPos.x = (elementWidth - context.measureText(line).width) / 2;
      } else if (this.textAlign === 'right') {
          textPos.x = elementWidth - context.measureText(line).width - this.paddingX;
      } else {
          textPos.x = this.paddingX;
      }
    },

    setTextVerticalAlign: function(textPos, textBlockHeight) {
      var elementHeight = (this.fitParent === false) ? this.canvas.height : this.canvas.parentNode.clientHeight;

      if (this.verticalAlign === 'middle') {
          textPos.y = (elementHeight - textBlockHeight) / 2;
      } else if (this.verticalAlign === 'bottom') {
          textPos.y = elementHeight - textBlockHeight - this.paddingY;
      } else {
          textPos.y = this.paddingY;
      }
    },

    validate: function() {
      if (isNodeJS) {
        if (!(this.canvas instanceof Canvas)) {
          throw new TypeError('From CanvasTextWrapper(): Element passed as the first parameter is not an instance of Canvas.');
        }
      } else {
        if (!(this.canvas instanceof HTMLCanvasElement)) {
          throw new TypeError('From CanvasTextWrapper(): Element passed as the first parameter is not an instance of HTMLCanvasElement.');
        }
      }
      if (typeof this.text !== 'string') {
          throw new TypeError('From CanvasTextWrapper(): The second, dedicated for the text, parameter must be a string.');
      }
      if (isNaN(this.lineHeight)) {
          throw new TypeError('From CanvasTextWrapper(): Cannot parse font size as an Integer. Check "font" property\'s value.');
      }
      if (this.textAlign !== 'left' && this.textAlign !== 'center' && this.textAlign !== 'right') {
          throw new TypeError('From CanvasTextWrapper(): Unsupported horizontal align value is used. Property "textAlign" can only be set to "left", "center", or "right".');
      }
      if (this.verticalAlign !== 'top' && this.verticalAlign !== 'middle' && this.verticalAlign !== 'bottom') {
          throw new TypeError('From CanvasTextWrapper(): Unsupported vertical align value is used. Property "verticalAlign" can only be set to "top", "middle", or "bottom".');
      }
      if (isNaN(this.paddingX)) {
          throw new TypeError('From CanvasTextWrapper(): Unsupported horizontal padding value is used. Property "paddingX" must be set to a number');
      }
      if (isNaN(this.paddingY)) {
          throw new TypeError('From CanvasTextWrapper(): Unsupported vertical padding value is used. Property "paddingY" must be set to a number.');
      }
      if (typeof this.fitParent !== 'boolean') {
          throw new TypeError('From CanvasTextWrapper(): Property "fitParent" must be set to a Boolean.');
      }
      if (this.lineBreak !== 'auto' && this.lineBreak !== 'word') {
          throw new TypeError('From CanvasTextWrapper(): Unsupported line break value is used. Property "lineBreak" can only be set to "auto", or "word".');
      }
      if (typeof this.sizeToFill !== 'boolean') {
          throw new TypeError('From CanvasTextWrapper(): Property "sizeToFill" must be set to a Boolean.');
      }
    }
  };

  this.MagicEye = MagicEye;

}).call(this);
